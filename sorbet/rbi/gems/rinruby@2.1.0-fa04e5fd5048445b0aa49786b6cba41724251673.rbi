# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `rinruby` gem.
# Please instead update this file by running `bin/tapioca gem rinruby`.

# R is an instance of RinRuby.  If for some reason the user does not want R to be initialized (to save system resources), then create a default value for R (e.g., <b>R=2</b> ) in which case RinRuby will not overwrite the value of R.
#
# source://rinruby//lib/rinruby.rb#1026
R = T.let(T.unsafe(nil), RinRuby)

# source://rinruby//lib/rinruby/version.rb#1
class RinRuby
  # RinRuby is invoked within a Ruby script (or the interactive "irb" prompt denoted >>) using:
  #
  #      >> require "rinruby"
  #
  # The previous statement reads the definition of the RinRuby class into the current Ruby interpreter and creates an instance of the RinRuby class named R. There is a second method for starting an instance of R which allows the user to use any name for the instance, in this case myr:
  #
  #      >> require "rinruby"
  #      >> myr = RinRuby.new
  #      >> myr.eval "rnorm(1)"
  #
  # Any number of independent instances of R can be created in this way.
  #
  # <b>Parameters that can be passed to the new method using a Hash:</b>
  #
  # * :echo: By setting the echo to false, output from R is suppressed, although warnings are still printed. This option can be changed later by using the echo method. The default is true.
  # * :interactive: When interactive is false, R is run in non-interactive mode, resulting in plots without an explicit device being written to Rplots.pdf. Otherwise (i.e., interactive is true), plots are shown on the screen. The default is true.
  # * :executable: The path of the R executable (which is "R" in Linux and Mac OS X, or "Rterm.exe" in Windows) can be set with the executable argument. The default is nil which makes RinRuby use the registry keys to find the path (on Windows) or use the path defined by $PATH (on Linux and Mac OS X).
  # * :port_number: This is the smallest port number on the local host that could be used to pass data between Ruby and R. The actual port number used depends on port_width.
  # * :port_width: RinRuby will randomly select a uniform number between port_number and port_number + port_width - 1 (inclusive) to pass data between Ruby and R. If the randomly selected port is not available, RinRuby will continue selecting random ports until it finds one that is available. By setting port_width to 1, RinRuby will wait until port_number is available. The default port_width is 1000.
  #
  # It may be desirable to change the parameters to the instance of R, but still call it by the name of R. In that case the old instance of R which was created with the 'require "rinruby"' statement should be closed first using the quit method which is explained below. Unless the previous instance is killed, it will continue to use system resources until exiting Ruby. The following shows an example by changing the parameter echo:
  #
  #      >> require "rinruby"
  #      >> R.quit
  #      >> R = RinRuby.new(false)
  #
  # @raise [Errno::EADDRINUSE]
  # @return [RinRuby] a new instance of RinRuby
  #
  # source://rinruby//lib/rinruby.rb#109
  def initialize(*args); end

  # Data is copied from Ruby to R using the assign method or a short-hand equivalent. For example:
  #
  #      >> names = ["Lisa","Teasha","Aaron","Thomas"]
  #      >> R.assign "people", names
  #      >> R.eval "sort(people)"
  #
  # produces the following :
  #
  #      [1] "Aaron"     "Lisa"     "Teasha" "Thomas"
  #
  # The short-hand equivalent to the assign method is simply:
  #
  #      >> R.people = names
  #
  # Some care is needed when using the short-hand of the assign method since the label (i.e., people in this case) must be a valid method name in Ruby. For example, R.copy.of.names = names will not work, but R.copy_of_names = names is permissible.
  #
  # The assign method supports Ruby variables of type Fixnum (i.e., integer), Bignum (i.e., integer), Float (i.e., double), String, and arrays of one of those three fundamental types. Note that Fixnum or Bignum values that exceed the capacity of R's integers are silently converted to doubles.  Data in other formats must be coerced when copying to R.
  #
  # <b>Parameters that can be passed to the assign method:</b>
  #
  # * name: The name of the variable desired in R.
  #
  # * value: The value the R variable should have. The assign method supports Ruby variables of type Fixnum (i.e., integer), Bignum (i.e., integer), Float (i.e., double), String, and arrays of one of those three fundamental types.  Note that Fixnum or Bignum values that exceed the capacity of R's integers are silently converted to doubles.  Data in other formats must be coerced when copying to R.
  #
  # The assign method is an alternative to the simplified method, with some additional flexibility. When using the simplified method, the parameters of name and value are automatically used, in other words:
  #
  #      >> R.test = 144
  #
  # is the same as:
  #
  #      >> R.assign("test",144)
  #
  # Of course it would be confusing to use the shorthand notation to assign a variable named eval, echo, or any other already defined function. RinRuby would assume you were calling the function, rather than trying to assign a variable.
  #
  # When assigning an array containing differing types of variables, RinRuby will follow R's conversion conventions. An array that contains any Strings will result in a character vector in R. If the array does not contain any Strings, but it does contain a Float or a large integer (in absolute value), then the result will be a numeric vector of Doubles in R. If there are only integers that are sufficiently small (in absolute value), then the result will be a numeric vector of integers in R.
  #
  # source://rinruby//lib/rinruby.rb#348
  def assign(name, value); end

  # @return [Boolean]
  #
  # source://rinruby//lib/rinruby.rb#902
  def complete?(string); end

  # The echo method controls whether the eval method displays output from R and, if echo is enabled, whether messages, warnings, and errors from stderr are also displayed.
  #
  # <b>Parameters that can be passed to the eval method</b>
  #
  # * enable: Setting enable to false will turn all output off until the echo command is used again with enable equal to true. The default is nil, which will return the current setting.
  #
  # * stderr: Setting stderr to true will force messages, warnings, and errors from R to be routed through stdout. Using stderr redirection is typically not needed, and is thus disabled by default. Echoing must be enabled when using stderr redirection.
  #
  # source://rinruby//lib/rinruby.rb#421
  def echo(enable = T.unsafe(nil), stderr = T.unsafe(nil)); end

  # Returns the value of attribute echo_enabled.
  #
  # source://rinruby//lib/rinruby.rb#78
  def echo_enabled; end

  # source://rinruby//lib/rinruby.rb#443
  def echo_enabled=(enable); end

  # The eval instance method passes the R commands contained in the supplied string and displays any resulting plots or prints the output. For example:
  #
  #      >>  sample_size = 10
  #      >>  R.eval "x <- rnorm(#{sample_size})"
  #      >>  R.eval "summary(x)"
  #      >>  R.eval "sd(x)"
  #
  # produces the following:
  #
  #         Min. 1st Qu.        Median      Mean 3rd Qu.         Max.
  #      -1.88900 -0.84930 -0.45220 -0.49290 -0.06069          0.78160
  #      [1] 0.7327981
  #
  # This example used a string substitution to make the argument to first eval method equivalent to x <- rnorm(10). This example used three invocations of the eval method, but a single invoke is possible using a here document:
  #
  #      >> R.eval <<EOF
  #              x <- rnorm(#{sample_size})
  #              summary(x)
  #              sd(x)
  #         EOF
  #
  # <b>Parameters that can be passed to the eval method</b>
  #
  # * string: The string parameter is the code which is to be passed to R, for example, string = "hist(gamma(1000,5,3))". The string can also span several lines of code by use of a here document, as shown:
  #      R.eval <<EOF
  #         x<-rgamma(1000,5,3)
  #         hist(x)
  #      EOF
  #
  # * echo_override: This argument allows one to set the echo behavior for this call only. The default for echo_override is nil, which does not override the current echo behavior.
  # * b: echo block, which will be used as echo_override when echo_override equals to nil
  #
  # source://rinruby//lib/rinruby.rb#225
  def eval(string, echo_override = T.unsafe(nil), &b); end

  # Returns the value of attribute executable.
  #
  # source://rinruby//lib/rinruby.rb#79
  def executable; end

  # Returns the value of attribute hostname.
  #
  # source://rinruby//lib/rinruby.rb#82
  def hostname; end

  # Returns the value of attribute interactive.
  #
  # source://rinruby//lib/rinruby.rb#76
  def interactive; end

  # If a method is called which is not defined, then it is assumed that the user is attempting to either pull or assign a variable to R.  This allows for the short-hand equivalents to the pull and assign methods.  For example:
  #
  #      >> R.x = 2
  #
  # is the same as:
  #
  #      >> R.assign("x",2)
  #
  # Also:
  #
  #      >> n = R.x
  #
  # is the same as:
  #
  #      >> n = R.pull("x")
  #
  # The parameters passed to method_missing are those used for the pull or assign depending on the context.
  #
  # source://rinruby//lib/rinruby.rb#300
  def method_missing(symbol, *args); end

  # Returns the value of attribute port_number.
  #
  # source://rinruby//lib/rinruby.rb#80
  def port_number; end

  # Returns the value of attribute port_width.
  #
  # source://rinruby//lib/rinruby.rb#81
  def port_width; end

  # When sending code to Ruby using an interactive prompt, this method will change the prompt to an R prompt. From the R prompt commands can be sent to R exactly as if the R program was actually running. When the user is ready to return to Ruby, then the command exit() will return the prompt to Ruby. This is the ideal situation for the explorative programmer who needs to run several lines of code in R, and see the results after each command. This is also an easy way to execute loops without the use of a here document. It should be noted that the prompt command does not work in a script, just Ruby's interactive irb.
  #
  # <b>Parameters that can be passed to the prompt method:</b>
  #
  # * regular_prompt: This defines the string used to denote the R prompt.
  #
  # * continue_prompt: This is the string used to denote R's prompt for an incomplete statement (such as a multiple for loop).
  #
  # source://rinruby//lib/rinruby.rb#248
  def prompt(regular_prompt = T.unsafe(nil), continue_prompt = T.unsafe(nil)); end

  # Data is copied from R to Ruby using the pull method or a short-hand equivalent. The R object x defined with an eval method can be copied to Ruby object copy_of_x as follows:
  #
  #      >> R.eval "x <- rnorm(10)"
  #      >> copy_of_x = R.pull "x"
  #      >> puts copy_of_x
  #
  # which produces the following :
  #
  #      -0.376404489256671
  #      -1.0759798269397
  #      -0.494240140140996
  #      0.131171385795721
  #      -0.878328334369391
  #      -0.762290423047929
  #      -0.410227216105828
  #      0.0445512804225151
  #      -1.88887454545995
  #      0.781602719849499
  #
  # RinRuby also supports a convenient short-hand notation when the argument to pull is simply a previously-defined R object (whose name conforms to Ruby's requirements for method names). For example:
  #
  #      >> copy_of_x = R.x
  #
  # The explicit assign method, however, can take an arbitrary R statement. For example:
  #
  #      >> summary_of_x = R.pull "as.numeric(summary(x))"
  #      >> puts summary_of_x
  #
  # produces the following:
  #
  #      -1.889
  #      -0.8493
  #      -0.4522
  #      -0.4929
  #      -0.06069
  #      0.7816
  #
  # Notice the use above of the as.numeric function in R. This is necessary since the pull method only supports R vectors which are numeric (i.e., integers or doubles) and character (i.e., strings). Data in other formats must be coerced when copying to Ruby.
  #
  # <b>Parameters that can be passed to the pull method:</b>
  #
  # * string: The name of the variable that should be pulled from R. The pull method only supports R vectors which are numeric (i.e., integers or doubles) or character (i.e., strings). The R value of NA is pulled as nil into Ruby. Data in other formats must be coerced when copying to Ruby.
  #
  # * singletons: R represents a single number as a vector of length one, but in Ruby it is often more convenient to use a number rather than an array of length one. Setting singleton=false will cause the pull method to shed the array, while singletons=true will return the number of string within an array.  The default is false.
  #
  # The pull method is an alternative to the simplified form where the parameters are automatically used.  For example:
  #
  #      >> puts R.test
  #
  # is the same as:
  #
  #      >> puts R.pull("test")
  #
  # source://rinruby//lib/rinruby.rb#407
  def pull(string, singletons = T.unsafe(nil)); end

  # The quit method will properly close the bridge between Ruby and R, freeing up system resources. This method does not need to be run when a Ruby script ends.
  #
  # source://rinruby//lib/rinruby.rb#182
  def quit; end

  # Returns the value of attribute readline.
  #
  # source://rinruby//lib/rinruby.rb#77
  def readline; end

  private

  # @raise [EngineClosed]
  #
  # source://rinruby//lib/rinruby.rb#787
  def assign_engine(fun, value, r_type = T.unsafe(nil)); end

  # @raise [EngineClosed]
  #
  # source://rinruby//lib/rinruby.rb#907
  def eval_engine(r_expr, &echo_proc); end

  # source://rinruby//lib/rinruby.rb#877
  def if_assignable(name, opt = T.unsafe(nil), &then_proc); end

  # source://rinruby//lib/rinruby.rb#881
  def if_complete(lines, &then_proc); end

  # source://rinruby//lib/rinruby.rb#874
  def if_parseable(string, opt = T.unsafe(nil), &then_proc); end

  # source://rinruby//lib/rinruby.rb#860
  def if_passed(string, r_func, opt = T.unsafe(nil), &then_proc); end

  # @raise [EngineClosed]
  #
  # source://rinruby//lib/rinruby.rb#822
  def pull_engine(string, singletons = T.unsafe(nil)); end

  # Create function on ruby to get values
  #
  # source://rinruby//lib/rinruby.rb#536
  def r_rinruby_assign; end

  # source://rinruby//lib/rinruby.rb#499
  def r_rinruby_check; end

  # source://rinruby//lib/rinruby.rb#575
  def r_rinruby_pull; end

  # :startdoc:
  #
  # source://rinruby//lib/rinruby.rb#473
  def r_rinruby_socket_io; end

  # source://rinruby//lib/rinruby.rb#613
  def socket_session(&b); end

  class << self
    # source://rinruby//lib/rinruby.rb#968
    def find_R_dir_on_windows(cygwin = T.unsafe(nil), &b); end

    # source://rinruby//lib/rinruby.rb#1007
    def find_R_on_windows(cygwin = T.unsafe(nil)); end

    # source://rinruby//lib/rinruby.rb#961
    def scrub(str); end
  end
end

# Exception for closed engine
#
# source://rinruby//lib/rinruby.rb#69
class RinRuby::EngineClosed < ::RuntimeError; end

# Parse error
#
# source://rinruby//lib/rinruby.rb#71
class RinRuby::ParseError < ::RuntimeError; end

# source://rinruby//lib/rinruby.rb#755
class RinRuby::R_Character < ::RinRuby::R_DataType
  class << self
    # @return [Boolean]
    #
    # source://rinruby//lib/rinruby.rb#758
    def convertable?(value); end

    # source://rinruby//lib/rinruby.rb#776
    def receive(io); end

    # source://rinruby//lib/rinruby.rb#763
    def send(value, io); end
  end
end

# source://rinruby//lib/rinruby.rb#756
RinRuby::R_Character::ID = T.let(T.unsafe(nil), Integer)

# source://rinruby//lib/rinruby.rb#650
class RinRuby::R_DataType
  class << self
    # source://rinruby//lib/rinruby.rb#656
    def ===(value); end

    # @return [Boolean]
    #
    # source://rinruby//lib/rinruby.rb#653
    def convertable?(value); end

    # source://rinruby//lib/rinruby.rb#662
    def receive(io); end

    # source://rinruby//lib/rinruby.rb#659
    def send(value, io); end
  end
end

# source://rinruby//lib/rinruby.rb#651
RinRuby::R_DataType::ID = T.let(T.unsafe(nil), Integer)

# source://rinruby//lib/rinruby.rb#722
class RinRuby::R_Double < ::RinRuby::R_DataType
  class << self
    # @return [Boolean]
    #
    # source://rinruby//lib/rinruby.rb#725
    def convertable?(value); end

    # source://rinruby//lib/rinruby.rb#745
    def receive(io); end

    # source://rinruby//lib/rinruby.rb#730
    def send(value, io); end
  end
end

# source://rinruby//lib/rinruby.rb#723
RinRuby::R_Double::ID = T.let(T.unsafe(nil), Integer)

# source://rinruby//lib/rinruby.rb#697
class RinRuby::R_Integer < ::RinRuby::R_DataType
  class << self
    # @return [Boolean]
    #
    # source://rinruby//lib/rinruby.rb#700
    def convertable?(value); end

    # source://rinruby//lib/rinruby.rb#713
    def receive(io); end

    # source://rinruby//lib/rinruby.rb#706
    def send(value, io); end
  end
end

# source://rinruby//lib/rinruby.rb#698
RinRuby::R_Integer::ID = T.let(T.unsafe(nil), Integer)

# source://rinruby//lib/rinruby.rb#668
class RinRuby::R_Logical < ::RinRuby::R_DataType
  class << self
    # @return [Boolean]
    #
    # source://rinruby//lib/rinruby.rb#678
    def convertable?(value); end

    # source://rinruby//lib/rinruby.rb#688
    def receive(io); end

    # source://rinruby//lib/rinruby.rb#681
    def send(value, io); end
  end
end

# source://rinruby//lib/rinruby.rb#670
RinRuby::R_Logical::CONVERT_TABLE = T.let(T.unsafe(nil), Hash)

# source://rinruby//lib/rinruby.rb#669
RinRuby::R_Logical::ID = T.let(T.unsafe(nil), Integer)

# source://rinruby//lib/rinruby.rb#74
RinRuby::RinRuby_Endian = T.let(T.unsafe(nil), Symbol)

# source://rinruby//lib/rinruby.rb#73
RinRuby::RinRuby_Env = T.let(T.unsafe(nil), String)

# source://rinruby//lib/rinruby.rb#466
RinRuby::RinRuby_Eval_Flag = T.let(T.unsafe(nil), String)

# source://rinruby//lib/rinruby.rb#469
RinRuby::RinRuby_Max_R_Integer = T.let(T.unsafe(nil), Integer)

# source://rinruby//lib/rinruby.rb#470
RinRuby::RinRuby_Min_R_Integer = T.let(T.unsafe(nil), Integer)

# source://rinruby//lib/rinruby.rb#468
RinRuby::RinRuby_NA_R_Integer = T.let(T.unsafe(nil), Integer)

# source://rinruby//lib/rinruby.rb#462
RinRuby::RinRuby_Socket = T.let(T.unsafe(nil), String)

# source://rinruby//lib/rinruby.rb#464
RinRuby::RinRuby_Test_Result = T.let(T.unsafe(nil), String)

# source://rinruby//lib/rinruby.rb#463
RinRuby::RinRuby_Test_String = T.let(T.unsafe(nil), String)

RinRuby::RinRuby_Type_Character = T.let(T.unsafe(nil), Integer)
RinRuby::RinRuby_Type_Double = T.let(T.unsafe(nil), Integer)
RinRuby::RinRuby_Type_Integer = T.let(T.unsafe(nil), Integer)
RinRuby::RinRuby_Type_Logical = T.let(T.unsafe(nil), Integer)
RinRuby::RinRuby_Type_Matrix = T.let(T.unsafe(nil), Integer)

# :stopdoc:
#
# source://rinruby//lib/rinruby.rb#450
RinRuby::RinRuby_Type_NotFound = T.let(T.unsafe(nil), Integer)

# source://rinruby//lib/rinruby.rb#451
RinRuby::RinRuby_Type_Unknown = T.let(T.unsafe(nil), Integer)

# source://rinruby//lib/rinruby/version.rb#2
RinRuby::VERSION = T.let(T.unsafe(nil), String)
